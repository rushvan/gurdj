




build-depends: base ^>=4.14.1.0 , aeson , bytestring , containers , plutus-ledger , plutus-ledger-api , plutus-tx , plutus-tx-plugin , plutus-contract , text



{-# LANGUAGE DataKinds #-} {-# LANGUAGE TemplateHaskell #-} {-# LANGUAGE NoImplicitPrelude #-} {-# LANGUAGE OverloadedStrings #-} {-# LANGUAGE TypeApplications #-} {-# LANGUAGE TypeFamilies #-} {-# LANGUAGE TypeOperators #-} module CardanoDefiProtocols where import PlutusTx import PlutusTx.Prelude import Ledger hiding (singleton) import Ledger.Constraints as Constraints import Ledger.Value as Value import Plutus.Contract import Plutus.V2.Ledger.Api import qualified Data.Map as Map import qualified Prelude as Haskell -- DEX (Decentralized Exchange) Protocol data SwapParams = SwapParams { spAsset1 :: AssetClass , spAsset2 :: AssetClass , spAmount1 :: Integer , spAmount2 :: Integer , spDeadline :: POSIXTime , spOwner :: PubKeyHash } PlutusTx.makeLift ''SwapParams data SwapAction = Swap | Cancel PlutusTx.unstableMakeIsData ''SwapAction {-# INLINABLE swapValidator #-} swapValidator :: SwapParams -> SwapAction -> ScriptContext -> Bool swapValidator sp action ctx = case action of Swap -> traceIfFalse "Deadline passed" deadlineNotPassed && traceIfFalse "Incorrect asset amounts" correctAssetAmounts && traceIfFalse "Incorrect output to owner" correctOutputToOwner Cancel -> traceIfFalse "Not authorized to cancel" signedByOwner where info :: TxInfo info = scriptContextTxInfo ctx deadlineNotPassed :: Bool deadlineNotPassed = to (spDeadline sp) `contains` txInfoValidRange info correctAssetAmounts :: Bool correctAssetAmounts = assetClassValueOf (valueSpent info) (spAsset1 sp) >= spAmount1 sp && assetClassValueOf (valuePaidTo info (ownHash ctx)) (spAsset2 sp) >= spAmount2 sp correctOutputToOwner :: Bool correctOutputToOwner = assetClassValueOf (valuePaidTo info (spOwner sp)) (spAsset2 sp) >= spAmount2 sp signedByOwner :: Bool signedByOwner = txSignedBy info (spOwner sp) -- DeFi Lending Protocol data LendingParams = LendingParams { lpCollateralAsset :: AssetClass , lpLoanAsset :: AssetClass , lpInterestRate :: Integer -- Represented as basis points (e.g., 500 = 5%) , lpLoanDuration :: POSIXTime , lpCollateralAmount :: Integer , lpLoanAmount :: Integer , lpBorrower :: PubKeyHash } PlutusTx.makeLift ''LendingParams data LendingAction = Borrow | Repay | Liquidate | Cancel PlutusTx.unstableMakeIsData ''LendingAction {-# INLINABLE lendingValidator #-} lendingValidator :: LendingParams -> LendingAction -> ScriptContext -> Bool lendingValidator lp action ctx = case action of Borrow -> traceIfFalse "Incorrect collateral" correctCollateral && traceIfFalse "Incorrect loan amount" correctLoanAmount Repay -> traceIfFalse "Incorrect repayment" correctRepayment && traceIfFalse "Loan duration not passed" loanDurationNotPassed Liquidate -> traceIfFalse "Loan duration not passed" loanDurationPassed && traceIfFalse "Collateral not transferred" collateralTransferred Cancel -> traceIfFalse "Not authorized to cancel" signedByBorrower where info :: TxInfo info = scriptContextTxInfo ctx correctCollateral :: Bool correctCollateral = assetClassValueOf (valueSpent info) (lpCollateralAsset lp) >= lpCollateralAmount lp correctLoanAmount :: Bool correctLoanAmount = assetClassValueOf (valuePaidTo info (lpBorrower lp)) (lpLoanAsset lp) >= lpLoanAmount lp correctRepayment :: Bool correctRepayment = let repaymentAmount = calculateRepaymentAmount lp info in assetClassValueOf (valueSpent info) (lpLoanAsset lp) >= repaymentAmount loanDurationNotPassed :: Bool loanDurationNotPassed = to (lpLoanDuration lp) `contains` txInfoValidRange info loanDurationPassed :: Bool loanDurationPassed = from (lpLoanDuration lp) `contains` txInfoValidRange info collateralTransferred :: Bool collateralTransferred = assetClassValueOf (valuePaidTo info (ownHash ctx)) (lpCollateralAsset lp) >= lpCollateralAmount lp signedByBorrower :: Bool signedByBorrower = txSignedBy info (lpBorrower lp) {-# INLINABLE calculateRepaymentAmount #-} calculateRepaymentAmount :: LendingParams -> TxInfo -> Integer calculateRepaymentAmount lp info = let loanPeriod = getPOSIXTime $ txInfoValidRange info interestAmount = (lpLoanAmount lp * lpInterestRate lp * loanPeriod) `divide` (10000 * 31536000000) -- Assuming interest rate is annual in lpLoanAmount lp + interestAmount -- Typed validators data Swapping instance Scripts.ValidatorTypes Swapping where type instance DatumType Swapping = SwapParams type instance RedeemerType Swapping = SwapAction swappingValidator :: Scripts.TypedValidator Swapping swappingValidator = Scripts.mkTypedValidator @Swapping $$(PlutusTx.compile [|| swapValidator ||]) $$(PlutusTx.compile [|| wrap ||]) where wrap = Scripts.wrapValidator @SwapParams @SwapAction data Lending instance Scripts.ValidatorTypes Lending where type instance DatumType Lending = LendingParams type instance RedeemerType Lending = LendingAction lendingValidator :: Scripts.TypedValidator Lending lendingValidator = Scripts.mkTypedValidator @Lending $$(PlutusTx.compile [|| lendingValidator ||]) $$(PlutusTx.compile [|| wrap ||]) where wrap = Scripts.wrapValidator @LendingParams @LendingAction -- Off-chain code (for interaction with the smart contracts) swap :: SwapParams -> Contract w s Text () swap sp = do let tx = Constraints.mustPayToTheScript sp (Value.assetClassValue (spAsset1 sp) (spAmount1 sp)) ledgerTx <- submitTxConstraints swappingValidator tx void $ awaitTxConfirmed $ getCardanoTxId ledgerTx logInfo @Haskell.String $ "Swap initiated: " ++ Haskell.show sp borrow :: LendingParams -> Contract w s Text () borrow lp = do let tx = Constraints.mustPayToTheScript lp (Value.assetClassValue (lpCollateralAsset lp) (lpCollateralAmount lp)) ledgerTx <- submitTxConstraints lendingValidator tx void $ awaitTxConfirmed $ getCardanoTxId ledgerTx logInfo @Haskell.String $ "Loan initiated: " ++ Haskell.show lp -- Main entry point for deployment main :: IO () main = do putStrLn "Deploying Cardano DeFi Protocols..." -- Here you would typically: -- 1. Compile the validators -- 2. Serialize the compiled validators -- 3. Write the serialized validators to files -- 4. Submit the validators to the Cardano blockchain -- This part depends on your specific deployment process and tools putStrLn "Deployment complete." -- Additional helper functions assetClassValue :: AssetClass -> Integer -> Value assetClassValue = Value.assetClassValue ownHash :: ScriptContext -> PubKeyHash ownHash = Ledger.scriptHash . Ledger.ownHash


